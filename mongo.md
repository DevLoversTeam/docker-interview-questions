<h1>
  MongoDB <img src="./assets/mongodb.svg" width="40" height="40" />
</h1>

<h2>Найпопулярніші запитання та відповіді на співбесіді з MongoDB</h2>

<details>
<summary>1. Що таке MongoDB?</summary>

#### MongoDB

**MongoDB** — це документно-орієнтована NoSQL база даних, яка зберігає дані у
вигляді BSON-документів у колекціях. Вона добре підходить для систем із
гнучкою схемою, високим навантаженням на читання/запис і швидкими змінами
структури даних.

Ключова ідея: замість жорстких таблиць і JOIN MongoDB працює з документами,
які можуть містити вкладені обʼєкти та масиви, що зменшує потребу в
нормалізації для багатьох прикладних сценаріїв.

**Коротко:**

- MongoDB — документна NoSQL база даних.
- Дані зберігаються як BSON-документи в колекціях.
- Орієнтована на гнучку схему та горизонтальне масштабування.

</details>

<details>
<summary>2. До якого типу баз даних належить MongoDB?</summary>

#### MongoDB

MongoDB належить до **NoSQL документних СУБД**. Це означає, що дані
організовуються не у рядки таблиць, а у документи, які логічно групуються в
колекції.

За CAP/розподіленими властивостями MongoDB проєктувалась як distributed database
з підтримкою replica sets і sharding, тому її часто використовують як
операційну базу для high-throughput застосунків.

**Коротко:**

- Тип: NoSQL, документно-орієнтована база даних.
- Одиниця зберігання: BSON-документ.
- Підтримує distributed-архітектуру (replica sets, sharding).

</details>

<details>
<summary>3. Які основні особливості MongoDB?</summary>

#### MongoDB

Основні особливості MongoDB:

1. **Документна модель даних**: природне зберігання вкладених структур.
2. **Гнучка схема**: поля можна додавати без міграцій таблиць у класичному SQL
   стилі.
3. **Потужний Aggregation Framework**: `$match`, `$group`, `$lookup`, `$project`,
   `$sort`, `$limit` для аналітики і трансформацій.
4. **Індекси**: single field, compound, text, TTL, partial та інші.
5. **Реплікація і відмовостійкість**: replica set з автоматичним failover.
6. **Горизонтальне масштабування**: sharding.
7. **Транзакції**: ACID-транзакції для multi-document операцій.
8. **Хмарна експлуатація через Atlas**: керований кластер, backup, monitoring.

**Коротко:**

- MongoDB поєднує гнучку модель документів і сильні можливості запитів.
- Має вбудовані індекси, реплікацію, шардінг і транзакції.
- Підходить як для операційних, так і для аналітичних сценаріїв.

</details>

<details>
<summary>4. У чому різниця між MongoDB і реляційними базами даних?</summary>

#### MongoDB

Головна різниця — **модель даних**:

- У MongoDB дані зберігаються в документах (BSON), часто з вкладеними
  структурами.
- У реляційних БД дані зберігаються у таблицях, повʼязаних через ключі.

Практичні відмінності:

1. **Схема**:
- MongoDB: гнучка/еволюційна схема.
- SQL БД: зазвичай жорстко визначена схема.

2. **Звʼязки**:
- MongoDB: embedding або referencing.
- SQL БД: JOIN як базовий механізм.

3. **Масштабування**:
- MongoDB: нативний sharding.
- SQL БД: частіше vertical scaling, шардінг складніший.

4. **Транзакційна модель**:
- Обидва підходи підтримують транзакції, але в MongoDB часто проєктують модель
  так, щоб мінімізувати потребу в multi-document транзакціях.

**Коротко:**

- MongoDB: документи + гнучка схема.
- SQL: таблиці + фіксована схема + JOIN-орієнтований підхід.
- Вибір залежить від моделі даних і навантаження системи.

</details>

<details>
<summary>5. Що таке документ у MongoDB?</summary>

#### MongoDB

**Документ** — це базова одиниця зберігання даних у MongoDB. Він має формат
BSON (бінарне представлення JSON-подібної структури) і складається з пар
`ключ: значення`.

Документ може містити:

- прості поля (`string`, `number`, `bool`, `date`);
- вкладені обʼєкти;
- масиви;
- службове поле `_id` (унікальний ідентифікатор).

Приклад структури документа:

```js
{
  _id: ObjectId("65f0c9d4e1b4d8a3f2a1b001"),
  name: "Iryna",
  skills: ["MongoDB", "Node.js"],
  profile: { level: "middle", active: true }
}
```

**Коротко:**

- Документ — основна сутність у MongoDB.
- Формат документа: BSON.
- Документи підтримують вкладені структури і масиви.

</details>

<details>
<summary>6. Що таке колекція?</summary>

#### MongoDB

**Колекція (collection)** — це набір документів у межах однієї бази даних
MongoDB. Концептуально це аналог таблиці в SQL, але без вимоги однакової
жорсткої схеми для кожного запису.

Колекції використовуються для групування документів однієї предметної області,
наприклад: `users`, `orders`, `products`.

Для продуктивності на колекції створюють індекси, а для життєвого циклу даних
можуть застосовувати TTL-індекси.

**Коротко:**

- Колекція — контейнер для документів.
- Аналог таблиці, але з гнучкішою схемою.
- На рівні колекції налаштовуються індекси та правила зберігання.

</details>

<details>
<summary>7. Що таке база даних у MongoDB?</summary>

#### MongoDB

**База даних (database)** у MongoDB — це логічний контейнер, який містить
колекції, індекси, метадані та повʼязані обʼєкти доступу.

Один MongoDB-кластер може мати багато баз даних. Типовий підхід:

- окрема БД на застосунок/сервіс;
- або окрема БД на оточення (`dev`, `staging`, `prod`).

У production середовищі важливо розділяти доступи на рівні БД і колекцій через
ролі та least-privilege policy.

**Коротко:**

- Database у MongoDB містить набір колекцій.
- Один кластер може обслуговувати багато баз даних.
- Ізоляція по БД часто використовується для середовищ і доступів.

</details>

<details>
<summary>8. Що таке BSON і чим він відрізняється від JSON?</summary>

#### MongoDB

**BSON (Binary JSON)** — це бінарний формат серіалізації, який MongoDB
використовує для зберігання та передачі документів.

Відмінності від JSON:

1. **Формат**:
- JSON — текстовий.
- BSON — бінарний (ефективніший для внутрішньої обробки в БД).

2. **Типи даних**:
- JSON має обмежений набір типів.
- BSON підтримує додаткові типи: `ObjectId`, `Date`, `Decimal128`, `Binary`,
  `Timestamp` тощо.

3. **Продуктивність**:
- BSON оптимізований для швидкого парсингу та доступу до полів у MongoDB.

На практиці клієнтський код працює з JSON-подібними структурами, а MongoDB
зберігає їх у BSON.

**Коротко:**

- BSON — бінарний формат даних MongoDB.
- BSON підтримує більше типів, ніж JSON.
- JSON зручний для API, BSON — для зберігання та обробки в БД.

</details>

<details>
<summary>9. Які типи даних підтримує MongoDB?</summary>

#### MongoDB

MongoDB підтримує базові та спеціалізовані BSON-типи:

- `String`
- `Boolean`
- `Int32`, `Int64`, `Double`
- `Decimal128`
- `Date`
- `ObjectId`
- `Array`
- `Document` (вкладений обʼєкт)
- `Null`
- `Binary`
- `Timestamp`
- `Regular Expression`

Практичні правила:

- для фінансових значень використовувати `Decimal128`;
- для часу подій — `Date` (UTC);
- для первинних ключів — `_id` (`ObjectId` або стабільний власний ключ за
  потреби).

**Коротко:**

- MongoDB працює з BSON-типами, не лише з базовими JSON-типами.
- Критичні типи для production: `ObjectId`, `Date`, `Decimal128`.
- Коректний вибір типу напряму впливає на індекси й запити.

</details>

<details>
<summary>10. Що таке поле _id і для чого воно використовується?</summary>

#### MongoDB

`_id` — це обовʼязкове унікальне поле кожного документа в колекції. Якщо під час
`insertOne` його не передати, MongoDB автоматично згенерує значення типу
`ObjectId`.

Призначення `_id`:

- однозначна ідентифікація документа;
- швидкий доступ через вбудований унікальний індекс;
- стабільне посилання на документ у звʼязках (referencing).

Приклад вставки з автоматичним `_id`:

```js
db.users.insertOne({ name: "Olena", email: "olena@example.com" })
```

Приклад вставки з власним `_id`:

```js
db.users.insertOne({ _id: "user_1001", name: "Olena" })
```

**Коротко:**

- `_id` є в кожному документі й завжди унікальний.
- За замовчуванням MongoDB генерує `_id` як `ObjectId`.
- На `_id` автоматично створюється унікальний індекс.

</details>

<details>
<summary>11. Що таке ObjectId і як він формується?</summary>

#### MongoDB

`ObjectId` — це 12-байтовий BSON-ідентифікатор, який MongoDB використовує як
стандартне значення `_id`.

Типово він містить:

- timestamp створення;
- випадкову частину для унікальності;
- інкрементний лічильник.

Через вбудований час створення `ObjectId` приблизно впорядковується за часом,
що часто зручно для сортування нових записів.

**Коротко:**

- `ObjectId` — стандартний унікальний ідентифікатор документа.
- Генерується автоматично, якщо `_id` не передано вручну.
- Містить часову компоненту, тому корисний для time-ordered вибірок.

</details>

<details>
<summary>12. Як вставити документ у MongoDB?</summary>

#### MongoDB

Для вставки одного документа використовується `insertOne`, для кількох —
`insertMany`.

```js
db.users.insertOne({
  email: "anna@example.com",
  profile: { name: "Anna", country: "UA" },
  createdAt: new Date(),
  isActive: true
})
```

```js
db.users.insertMany([
  { email: "oleh@example.com", createdAt: new Date(), isActive: true },
  { email: "ira@example.com", createdAt: new Date(), isActive: false }
], { ordered: false })
```

`ordered: false` дозволяє продовжувати batch-вставку, навіть якщо окремий
документ не пройшов валідацію або порушив унікальний індекс.

**Коротко:**

- `insertOne` для одного документа, `insertMany` для batch-вставки.
- Якщо `_id` не задано, MongoDB створює його автоматично.
- Для масових вставок у production часто використовують `ordered: false`.

</details>

<details>
<summary>13. Як знайти документи за умовою?</summary>

#### MongoDB

Базовий пошук виконується через `find(filter, projection)`.

```js
db.orders.find(
  { status: "paid", total: { $gte: 1000 } },
  { _id: 1, customerId: 1, total: 1, createdAt: 1 }
)
```

Для одного документа зручно використовувати `findOne`:

```js
db.orders.findOne({ _id: ObjectId("65f0c9d4e1b4d8a3f2a1b001") })
```

**Коротко:**

- Основний API для пошуку: `find`.
- Умови задаються у `filter` через оператори MongoDB.
- Для одиничного запису використовують `findOne`.

</details>

<details>
<summary>14. Як оновити документ?</summary>

#### MongoDB

Оновлення виконують через `updateOne` або `updateMany` з операторами, наприклад
`$set`, `$inc`, `$unset`.

```js
db.users.updateOne(
  { email: "anna@example.com" },
  {
    $set: { isActive: true, "profile.country": "PL" },
    $inc: { loginCount: 1 }
  }
)
```

Upsert (створити, якщо документа немає):

```js
db.users.updateOne(
  { email: "new.user@example.com" },
  { $set: { isActive: true, createdAt: new Date() } },
  { upsert: true }
)
```

**Коротко:**

- `updateOne`/`updateMany` змінюють документи за фільтром.
- Зміни задаються через оператори (`$set`, `$inc`, ...).
- `upsert: true` обʼєднує update + insert.

</details>

<details>
<summary>15. Як видалити документ?</summary>

#### MongoDB

Для видалення одного документа використовують `deleteOne`, для масового —
`deleteMany`.

```js
db.sessions.deleteOne({ _id: ObjectId("65f0c9d4e1b4d8a3f2a1b0aa") })
```

```js
db.sessions.deleteMany({ expiresAt: { $lt: new Date() } })
```

У production важливо не запускати `deleteMany({})` без явної потреби.

**Коротко:**

- `deleteOne` видаляє перший відповідний документ.
- `deleteMany` видаляє всі документи, що відповідають фільтру.
- Фільтр має бути максимально точним для безпечного видалення.

</details>

<details>
<summary>16. Що таке оператори порівняння в MongoDB?</summary>

#### MongoDB

Оператори порівняння використовуються у фільтрах для умовного пошуку:
`$eq`, `$ne`, `$gt`, `$gte`, `$lt`, `$lte`.

```js
db.products.find({ price: { $gte: 100, $lt: 500 } })
```

```js
db.users.find({ status: { $ne: "blocked" } })
```

Вони комбінуються з логічними операторами (`$and`, `$or`) для складних умов.

**Коротко:**

- Оператори порівняння задають умови відбору документів.
- Найчастіше: `$gt/$gte/$lt/$lte/$ne`.
- Ефективність залежить від наявності релевантного індексу.

</details>

<details>
<summary>17. Як працюють оператори $in і $nin?</summary>

#### MongoDB

`$in` перевіряє, чи значення поля входить до набору, `$nin` — чи не входить.

```js
db.orders.find({ status: { $in: ["new", "paid", "processing"] } })
```

```js
db.orders.find({ status: { $nin: ["canceled", "archived"] } })
```

Для великих списків значень краще обмежувати розмір масиву і перевіряти план
через `explain()`.

**Коротко:**

- `$in` = входить у список, `$nin` = не входить.
- Зручно для фільтрації по whitelist/blacklist статусів.
- На великих списках потрібен контроль продуктивності через `explain()`.

</details>

<details>
<summary>18. Як працює оператор $exists?</summary>

#### MongoDB

`$exists` перевіряє, чи поле присутнє в документі.

```js
db.users.find({ middleName: { $exists: true } })
```

```js
db.users.find({ deletedAt: { $exists: false } })
```

Оператор перевіряє факт наявності поля, а не його значення. Поле може існувати
і мати `null`.

**Коротко:**

- `$exists: true` шукає документи з полем.
- `$exists: false` шукає документи без поля.
- Наявність поля і значення `null` — різні випадки.

</details>

<details>
<summary>19. Як виконати сортування результатів?</summary>

#### MongoDB

Сортування виконується методом `sort()`:

- `1` — за зростанням;
- `-1` — за спаданням.

```js
db.orders
  .find({ status: "paid" })
  .sort({ createdAt: -1, _id: -1 })
  .limit(50)
```

Для стабільного порядку часто додають другий ключ (наприклад `_id`).

**Коротко:**

- `sort({ field: 1|-1 })` керує порядком результатів.
- Стабільне сортування роблять за кількома полями.
- Найкраща продуктивність при індексі, сумісному з `filter + sort`.

</details>

<details>
<summary>20. Як реалізувати пагінацію за допомогою limit і skip?</summary>

#### MongoDB

Базова пагінація:

```js
const page = 3
const pageSize = 20

db.posts
  .find({ isPublished: true })
  .sort({ createdAt: -1, _id: -1 })
  .skip((page - 1) * pageSize)
  .limit(pageSize)
```

`skip` з великими значеннями стає дорогим. Для великих наборів даних краще
cursor-based пагінація (за `createdAt + _id`).

**Коротко:**

- `skip + limit` — простий спосіб пагінації.
- Працює добре на невеликих/середніх зміщеннях.
- Для deep pagination краще cursor-based підхід.

</details>

<details>
<summary>21. Що таке проєкція (projection)?</summary>

#### MongoDB

Проєкція визначає, які поля повертати з документа у результаті запиту.

```js
db.users.find(
  { isActive: true },
  { _id: 0, email: 1, "profile.name": 1 }
)
```

Це зменшує обсяг даних у відповіді і мережеві витрати.

**Коротко:**

- Projection контролює склад полів у результаті.
- Допомагає зменшити payload і прискорити читання.
- Часто використовується разом із індексами для covered query.

</details>

<details>
<summary>22. Як вибрати тільки певні поля документа?</summary>

#### MongoDB

Потрібні поля задають у другому аргументі `find` або через `.project()` в
`aggregate`.

```js
db.products.find(
  { category: "laptop" },
  { _id: 1, title: 1, price: 1, stock: 1 }
)
```

Для виключення поля використовують `0`:

```js
db.products.find({ category: "laptop" }, { internalNotes: 0 })
```

**Коротко:**

- Вибір полів керується проєкцією у `find`.
- `1` включає поле, `0` виключає.
- Мінімальний набір полів покращує продуктивність запитів.

</details>

<details>
<summary>23. Як працює пошук за регулярними виразами?</summary>

#### MongoDB

Пошук за regex працює через оператор `$regex`.

```js
db.users.find({ email: { $regex: "@example\\.com$", $options: "i" } })
```

Для префіксного пошуку (наприклад `^ann`) можна використовувати індекс краще,
ніж для довільного шаблону `.*ann.*`.

Для повнотекстового пошуку по словах краще використовувати `text index`, а не
regex по великих колекціях.

**Коротко:**

- Regex дозволяє патерн-пошук у рядках.
- Префіксні шаблони ефективніші за довільні.
- Для лінгвістичного пошуку краще `text index`.

</details>

<details>
<summary>24. Що таке вкладені документи?</summary>

#### MongoDB

Вкладений документ — це обʼєкт усередині іншого документа.

```js
{
  _id: ObjectId("65f0c9d4e1b4d8a3f2a1b101"),
  customer: {
    name: "Olha",
    address: { city: "Kyiv", zip: "01001" }
  }
}
```

Доступ до полів виконується через dot notation:

```js
db.orders.find({ "customer.address.city": "Kyiv" })
```

**Коротко:**

- Вкладені документи моделюють ієрархічні дані.
- Доступ до полів — через dot notation.
- Часто зменшують потребу в JOIN-подібних операціях.

</details>

<details>
<summary>25. Як працювати з масивами в MongoDB?</summary>

#### MongoDB

MongoDB нативно підтримує масиви в документах і дозволяє фільтрувати, оновлювати
та агрегувати їх.

```js
db.posts.insertOne({
  title: "MongoDB tips",
  tags: ["mongodb", "backend", "nosql"],
  ratings: [5, 4, 5]
})
```

Запити можуть перевіряти наявність елемента, розмір масиву або умови для
елементів (`$elemMatch`).

**Коротко:**

- Масиви є вбудованим типом BSON.
- По масивах доступні фільтри, оновлення і агрегації.
- Для складних умов по елементах використовують `$elemMatch`.

</details>

<details>
<summary>26. Як знайти документи за значенням у масиві?</summary>

#### MongoDB

Якщо поле-масив містить значення, документ підходить під фільтр.

```js
db.posts.find({ tags: "mongodb" })
```

Для кількох умов по елементах масиву:

```js
db.products.find({ specs: { $elemMatch: { key: "ram", value: "16GB" } } })
```

**Коротко:**

- `field: value` працює і для масивів (перевірка containment).
- `$elemMatch` потрібен для складних умов на елемент масиву.
- Індекс на масивне поле може суттєво прискорити запит.

</details>

<details>
<summary>27. Як оновити елемент у масиві?</summary>

#### MongoDB

Для оновлення першого відповідного елемента використовують позиційний оператор
`$`.

```js
db.orders.updateOne(
  { _id: ObjectId("65f0c9d4e1b4d8a3f2a1b201"), "items.sku": "SKU-100" },
  { $set: { "items.$.qty": 3 } }
)
```

Для оновлення кількох елементів застосовують `arrayFilters`:

```js
db.orders.updateOne(
  { _id: ObjectId("65f0c9d4e1b4d8a3f2a1b201") },
  { $set: { "items.$[it].discount": 10 } },
  { arrayFilters: [{ "it.category": "accessories" }] }
)
```

**Коротко:**

- `$` оновлює перший знайдений елемент масиву.
- `arrayFilters` дозволяє таргетувати групу елементів.
- Фільтр і шлях до масиву мають бути максимально конкретними.

</details>

<details>
<summary>28. Що робить оператор $push?</summary>

#### MongoDB

`$push` додає новий елемент у масив.

```js
db.posts.updateOne(
  { _id: ObjectId("65f0c9d4e1b4d8a3f2a1b301") },
  { $push: { tags: "performance" } }
)
```

Можна додати кілька елементів і обмежити масив:

```js
db.posts.updateOne(
  { _id: ObjectId("65f0c9d4e1b4d8a3f2a1b301") },
  { $push: { comments: { $each: [{ by: "admin", text: "ok" }], $slice: -50 } } }
)
```

**Коротко:**

- `$push` додає елемент у кінець масиву.
- Через `$each` можна додати кілька елементів за раз.
- `$slice` допомагає обмежувати розмір масиву.

</details>

<details>
<summary>29. Що робить оператор $pull?</summary>

#### MongoDB

`$pull` видаляє з масиву всі елементи, що відповідають умові.

```js
db.posts.updateOne(
  { _id: ObjectId("65f0c9d4e1b4d8a3f2a1b301") },
  { $pull: { tags: "deprecated" } }
)
```

Приклад для масиву обʼєктів:

```js
db.orders.updateOne(
  { _id: ObjectId("65f0c9d4e1b4d8a3f2a1b201") },
  { $pull: { items: { qty: { $lte: 0 } } } }
)
```

**Коротко:**

- `$pull` видаляє елементи масиву за умовою.
- Працює і для простих значень, і для обʼєктів.
- Зручно для очистки неактуальних або невалідних елементів.

</details>

<details>
<summary>30. Як працює оператор $addToSet?</summary>

#### MongoDB

`$addToSet` додає значення в масив тільки якщо такого значення ще немає.

```js
db.users.updateOne(
  { _id: ObjectId("65f0c9d4e1b4d8a3f2a1b401") },
  { $addToSet: { roles: "editor" } }
)
```

Для кількох значень:

```js
db.users.updateOne(
  { _id: ObjectId("65f0c9d4e1b4d8a3f2a1b401") },
  { $addToSet: { roles: { $each: ["reviewer", "editor"] } } }
)
```

**Коротко:**

- `$addToSet` додає в масив лише унікальні значення.
- Запобігає дублюванню елементів.
- Для batch-додавання використовується `$each`.

</details>

<details>
<summary>31. Що таке індекс у MongoDB і навіщо він потрібен?</summary>

#### MongoDB

Індекс — це структура даних, що прискорює пошук і сортування, зменшуючи обсяг
документів для сканування.

Без індексу MongoDB часто виконує `COLLSCAN` (повний перегляд колекції). З
індексом запит переходить до `IXSCAN`, що суттєво швидше на великих обсягах.

Індекси мають ціну: споживання RAM/диску і додаткові витрати на запис.

**Коротко:**

- Індекс прискорює читання і сортування.
- Зменшує ризик повного сканування колекції.
- Надмірна кількість індексів погіршує швидкість запису.

</details>

<details>
<summary>32. Які типи індексів підтримує MongoDB?</summary>

#### MongoDB

Найуживаніші типи індексів:

- single field;
- compound;
- multikey (для масивів);
- text;
- TTL;
- hashed;
- wildcard;
- geospatial (`2d`, `2dsphere`).

Вибір індексу залежить від реальних патернів запитів, а не лише від структури
документів.

**Коротко:**

- MongoDB має кілька типів індексів для різних задач.
- Базові production-випадки: single, compound, text, TTL.
- Тип індексу має відповідати конкретному workload.

</details>

<details>
<summary>33. Що таке compound index?</summary>

#### MongoDB

`Compound index` індексує кілька полів в одному індексі, наприклад:
`{ status: 1, createdAt: -1 }`.

```js
db.orders.createIndex({ status: 1, createdAt: -1 })
```

Такий індекс ефективний для запитів, які фільтрують по `status` і сортують по
`createdAt`, або використовують префікс індексу (тільки `status`).

**Коротко:**

- Compound index містить кілька полів.
- Ключовий порядок полів визначає ефективність.
- Має покривати реальні `filter + sort` сценарії.

</details>

<details>
<summary>34. Що таке text index?</summary>

#### MongoDB

`Text index` використовується для пошуку слів і фраз у текстових полях через
оператор `$text`.

```js
db.articles.createIndex({ title: "text", body: "text" })
```

```js
db.articles.find(
  { $text: { $search: "mongodb replication" } },
  { score: { $meta: "textScore" }, title: 1 }
).sort({ score: { $meta: "textScore" } })
```

Підходить для базового full-text. Для складного relevance/ranking зазвичай
використовують Atlas Search.

**Коротко:**

- `text index` забезпечує текстовий пошук через `$text`.
- Дає `textScore` для ранжування результатів.
- Для розширеного пошуку краще Atlas Search.

</details>

<details>
<summary>35. Що таке TTL-індекс?</summary>

#### MongoDB

TTL-індекс автоматично видаляє документи після завершення заданого часу життя.

```js
db.sessions.createIndex(
  { expiresAt: 1 },
  { expireAfterSeconds: 0 }
)
```

У цьому прикладі документ видаляється, коли `expiresAt` стає меншим за поточний
час.

TTL підходить для сесій, тимчасових токенів, логів із retention policy.

**Коротко:**

- TTL-індекс автоматизує видалення за часом.
- Працює через поле дати і `expireAfterSeconds`.
- Зручний для даних із обмеженим життєвим циклом.

</details>

<details>
<summary>36. Як створити індекс?</summary>

#### MongoDB

Індекс створюється через `createIndex`.

```js
db.users.createIndex({ email: 1 }, { unique: true, name: "ux_users_email" })
```

```js
db.orders.createIndex({ customerId: 1, createdAt: -1 }, { name: "ix_orders_customer_created" })
```

Перед створенням індексу варто перевірити `explain()` для топ-запитів і
створювати індекси під фактичні шаблони доступу.

**Коротко:**

- `createIndex` створює індекс по одному або кількох полях.
- Часто додають `unique` і явне `name`.
- Індексувати потрібно під реальні запити, а не "про всяк випадок".

</details>

<details>
<summary>37. Як перевірити наявні індекси в колекції?</summary>

#### MongoDB

Для перегляду індексів використовують `getIndexes()`.

```js
db.users.getIndexes()
```

Для статистики використання індексів у довшому періоді можна застосовувати
`$indexStats` в aggregation.

```js
db.users.aggregate([{ $indexStats: {} }])
```

**Коротко:**

- `getIndexes()` показує конфігурацію індексів колекції.
- `$indexStats` допомагає знайти невикористовувані індекси.
- Регулярний аудит індексів знижує write overhead.

</details>

<details>
<summary>38. Що таке index cardinality і чому вона важлива?</summary>

#### MongoDB

`Index cardinality` — це кількість унікальних значень у полі індексу.

- Висока cardinality (наприклад `email`) зазвичай дає кращу селективність.
- Низька cardinality (наприклад `isActive: true/false`) може бути слабкою для
  самостійного індексу.

Тому індекси по низькокардинальних полях часто комбінують з іншими полями в
compound-індекс.

**Коротко:**

- Cardinality впливає на селективність індексу.
- Висока cardinality зазвичай ефективніша для фільтрації.
- Низьку cardinality часто компенсують compound-індексом.

</details>

<details>
<summary>39. Що таке covered query?</summary>

#### MongoDB

`Covered query` — це запит, який повністю обслуговується індексом без читання
документів з колекції.

Умова: і поля фільтра, і поля проєкції мають бути в одному індексі.

```js
db.users.createIndex({ email: 1, isActive: 1 })

db.users.find(
  { email: "anna@example.com" },
  { _id: 0, email: 1, isActive: 1 }
)
```

Перевірка робиться через `explain()` (відсутність стадії читання документа з
колекції).

**Коротко:**

- Covered query читає дані тільки з індексу.
- Потрібно, щоб `filter + projection` покривалися одним індексом.
- Це зменшує I/O і прискорює читання.

</details>

<details>
<summary>40. Як уникнути collection scan?</summary>

#### MongoDB

Щоб уникати `COLLSCAN`, потрібні індекси під фактичні запити та регулярний
аналіз планів виконання.

Практичний підхід:

1. Додати індекси під `filter + sort` найкритичніших запитів.
2. Перевіряти `explain("executionStats")`.
3. Зменшувати payload через проєкцію.
4. Уникати неіндексованих regex і великих `skip`.

```js
db.orders.find({ customerId: 1001, status: "paid" }).sort({ createdAt: -1 }).explain("executionStats")
```

Якщо в плані переважає `IXSCAN` замість `COLLSCAN`, стратегія індексації працює
коректно.

**Коротко:**

- Основний інструмент проти `COLLSCAN` — правильні індекси.
- `explain("executionStats")` показує реальну ефективність запиту.
- Проєкція і коректний патерн пагінації також знижують сканування.

</details>

<details>
<summary>41. Що таке explain() і як його використовувати?</summary>

#### MongoDB

`explain()` показує план виконання запиту: які індекси використано, скільки
документів/ключів переглянуто, де виникають вузькі місця.

```js
db.orders.find({ customerId: 1001 }).sort({ createdAt: -1 }).explain("executionStats")
```

Основні режими: `queryPlanner`, `executionStats`, `allPlansExecution`.

**Коротко:**

- `explain()` дає фактичний план виконання запиту.
- Для оптимізації найчастіше використовують `executionStats`.
- Дозволяє виявити `COLLSCAN`, неефективні індекси і дорогі сортування.

</details>

<details>
<summary>42. Як аналізувати продуктивність запитів?</summary>

#### MongoDB

Практичний підхід:

1. Визначити повільні запити через profiler/Atlas metrics.
2. Перевірити `explain("executionStats")`.
3. Порівняти `docsExamined`, `keysExamined`, `nReturned`.
4. Додати або переробити індекс під `filter + sort`.
5. Зменшити payload через projection.

**Коротко:**

- Аналіз починається з пошуку реальних slow queries.
- Ключові метрики: `docsExamined`, `keysExamined`, latency.
- Оптимізація: індекси, projection, коректний шаблон запиту.

</details>

<details>
<summary>43. Що таке aggregation framework?</summary>

#### MongoDB

Aggregation Framework — це механізм обробки даних через послідовність стадій
pipeline для фільтрації, трансформації, групування та обчислень.

```js
db.orders.aggregate([
  { $match: { status: "paid" } },
  { $group: { _id: "$customerId", total: { $sum: "$total" } } }
])
```

**Коротко:**

- Aggregation виконує аналітичну і трансформаційну обробку в БД.
- Працює через pipeline зі стадіями.
- Зменшує потребу у постобробці на рівні застосунку.

</details>

<details>
<summary>44. Що таке pipeline в aggregation?</summary>

#### MongoDB

Pipeline — це впорядкований масив стадій, де вихід попередньої стадії є входом
наступної.

```js
db.events.aggregate([
  { $match: { type: "login" } },
  { $project: { userId: 1, createdAt: 1 } },
  { $sort: { createdAt: -1 } },
  { $limit: 100 }
])
```

Порядок стадій критично впливає на продуктивність.

**Коротко:**

- Pipeline = послідовність стадій обробки.
- Дані проходять стадії зліва направо.
- Ранній `$match` і мінімальний `$project` знижують витрати.

</details>

<details>
<summary>45. Що робить стадія $match?</summary>

#### MongoDB

`$match` фільтрує документи за умовою (аналог `find` у pipeline).

```js
db.orders.aggregate([
  { $match: { status: "paid", total: { $gte: 1000 } } }
])
```

Ставіть `$match` максимально рано, щоб зменшити обсяг даних на наступних
стадіях.

**Коротко:**

- `$match` відбирає документи за критеріями.
- Найефективніше розміщувати на початку pipeline.
- Може використовувати індекси, якщо стоїть до трансформаційних стадій.

</details>

<details>
<summary>46. Що робить стадія $group?</summary>

#### MongoDB

`$group` агрегує документи за ключем і обчислює метрики (`$sum`, `$avg`, `$max`,
`$min`, `$count`).

```js
db.orders.aggregate([
  { $group: { _id: "$status", totalAmount: { $sum: "$total" }, cnt: { $sum: 1 } } }
])
```

**Коротко:**

- `$group` виконує групування та агрегації.
- Ключ групування задається через `_id`.
- Може бути ресурсомістким без попереднього `$match`.

</details>

<details>
<summary>47. Що робить стадія $project?</summary>

#### MongoDB

`$project` формує структуру вихідного документа: включає/виключає поля,
перейменовує їх і обчислює нові.

```js
db.users.aggregate([
  {
    $project: {
      _id: 0,
      email: 1,
      fullName: { $concat: ["$profile.firstName", " ", "$profile.lastName"] }
    }
  }
])
```

**Коротко:**

- `$project` керує фінальним набором полів.
- Дозволяє обчислювати нові поля в pipeline.
- Зменшує payload і спрощує формат відповіді.

</details>

<details>
<summary>48. Що робить стадія $sort?</summary>

#### MongoDB

`$sort` впорядковує документи за одним або кількома полями.

```js
db.orders.aggregate([
  { $match: { status: "paid" } },
  { $sort: { createdAt: -1, _id: -1 } }
])
```

Для великих вибірок без відповідного індексу сортування може бути дорогим.

**Коротко:**

- `$sort` задає порядок документів.
- Стабільність часто забезпечують додаванням `_id`.
- Індекс під `match + sort` критичний для продуктивності.

</details>

<details>
<summary>49. Що таке $lookup і як він працює?</summary>

#### MongoDB

`$lookup` виконує приєднання даних з іншої колекції (аналог JOIN).

```js
db.orders.aggregate([
  {
    $lookup: {
      from: "users",
      localField: "customerId",
      foreignField: "_id",
      as: "customer"
    }
  }
])
```

Результат додається як масив у поле `as`.

**Коротко:**

- `$lookup` об'єднує дані між колекціями.
- Повертає пов'язані записи масивом.
- Потребує індексів на полях зв'язку для ефективності.

</details>

<details>
<summary>50. Які best practices для оптимізації aggregation?</summary>

#### MongoDB

Основні практики:

1. Розміщувати `$match` і `$project` якомога раніше.
2. Мінімізувати кількість документів до `$group`/`$lookup`.
3. Використовувати індекси під стартові стадії.
4. Перевіряти `explain()` для pipeline.
5. Уникати зайвих проміжних полів і великих документів.

**Коротко:**

- Рання фільтрація і проєкція дають найбільший виграш.
- Важкі стадії (`$group`, `$lookup`, `$sort`) мають отримувати мінімум даних.
- Оптимізацію підтверджують тільки через `explain()` та метрики.

</details>

<details>
<summary>51. Що таке schema design у MongoDB?</summary>

#### MongoDB

Schema design — це проєктування структури документів, колекцій і зв'язків під
конкретні запити, патерни читання/запису і масштабування.

У MongoDB модель орієнтують на read/write workload, а не на жорстку
нормалізацію.

**Коротко:**

- Schema design визначає форму даних і зв'язки.
- Модель будується під реальні запити.
- Ключове рішення: embedding vs referencing.

</details>

<details>
<summary>52. Коли варто використовувати embedding?</summary>

#### MongoDB

Embedding доцільний, коли пов'язані дані:

- часто читаються разом;
- мають відношення 1:1 або 1:few;
- оновлюються в межах одного документа.

Приклад: профіль користувача з налаштуваннями та контактами.

**Коротко:**

- Embedding зменшує кількість запитів і потребу в `$lookup`.
- Підходить для компактних тісно пов'язаних даних.
- Не варто використовувати для необмежено зростаючих списків.

</details>

<details>
<summary>53. Коли краще використовувати references?</summary>

#### MongoDB

References кращі, коли:

- зв'язок many-to-many;
- піддокументи великі або ростуть без меж;
- пов'язані частини мають різні цикли оновлення;
- потрібен незалежний доступ до сутностей.

**Коротко:**

- References зменшують ризик надмірного росту документа.
- Підходять для складних графів зв'язків.
- Часто потребують додаткових запитів або `$lookup`.

</details>

<details>
<summary>54. Які переваги та недоліки embedding?</summary>

#### MongoDB

Переваги:

- швидке читання пов'язаних даних одним запитом;
- атомарні оновлення в межах документа;
- простіша модель доступу.

Недоліки:

- ризик великого документа;
- дублювання даних при повторному використанні сутності;
- складніше оновлювати спільні дані в багатьох документах.

**Коротко:**

- Embedding оптимізує читання і локальні оновлення.
- Основні ризики: ріст документа і дублювання.
- Вибір залежить від патернів доступу, а не від теорії нормалізації.

</details>

<details>
<summary>55. Що таке денормалізація в MongoDB?</summary>

#### MongoDB

Денормалізація — це свідоме дублювання даних у документах для зменшення
кількості JOIN-подібних операцій і прискорення читання.

Приклад: збереження `customerName` в документі замовлення разом з `customerId`.

**Коротко:**

- Денормалізація підвищує швидкість читання.
- Компроміс: складніша синхронізація дубльованих полів.
- Працює найкраще, коли читання домінує над записом.

</details>

<details>
<summary>56. Як уникнути надмірного росту документів?</summary>

#### MongoDB

Практики:

- не зберігати безмежні масиви в одному документі;
- архівувати або виносити історію в окрему колекцію;
- використовувати references для "довгих" списків;
- застосовувати TTL для тимчасових даних;
- контролювати розмір документа при моделюванні.

**Коротко:**

- Найбільший ризик росту: безмежні масиви і логи в документі.
- "Гарячу" і "історичну" частину даних краще розділяти.
- Правильна модель даних попереджає проблеми продуктивності.

</details>

<details>
<summary>57. Що таке schema validation?</summary>

#### MongoDB

Schema validation — це правила на рівні колекції, які перевіряють структуру і
типи документів під час `insert`/`update`.

Це знижує ризик невалідних даних у production.

**Коротко:**

- Validation застосовує контракт даних у самій БД.
- Перевіряє типи, обов'язкові поля, обмеження.
- Працює як додатковий захист до валідації в застосунку.

</details>

<details>
<summary>58. Як працює JSON Schema validation у MongoDB?</summary>

#### MongoDB

MongoDB підтримує валідацію через `$jsonSchema` у `validator` колекції.

```js
db.createCollection("users", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["email", "createdAt"],
      properties: {
        email: { bsonType: "string" },
        createdAt: { bsonType: "date" },
        isActive: { bsonType: "bool" }
      }
    }
  }
})
```

**Коротко:**

- `$jsonSchema` задає формальний контракт документа.
- Перевіряє `bsonType`, required-поля і обмеження.
- Допомагає тримати однорідну структуру даних.

</details>

<details>
<summary>59. Коли варто використовувати schema validation?</summary>

#### MongoDB

Validation доцільний, коли:

- дані пишуть кілька сервісів;
- схема критична для аналітики/білінгу/звітів;
- потрібен захист від випадкових змін payload;
- потрібен контроль міграцій схеми.

**Коротко:**

- Використовуйте validation для критичних і спільних даних.
- Це захист від "schema drift" у distributed-системах.
- Гнучка схема MongoDB не скасовує потребу в контракті.

</details>

<details>
<summary>60. Які best practices для моделювання даних у MongoDB?</summary>

#### MongoDB

Базові практики:

1. Проєктувати схему від запитів (query-first).
2. Обирати embedding/referencing за патернами доступу.
3. Планувати індекси разом зі схемою.
4. Тримати документи компактними.
5. Використовувати однакові типи полів у всій колекції.

**Коротко:**

- Модель даних має відповідати реальному workload.
- Схема, індекси і запити проєктуються разом.
- Стабільність типів і контроль росту документів критичні.

</details>

<details>
<summary>61. Що таке транзакції в MongoDB?</summary>

#### MongoDB

Транзакції в MongoDB — це ACID-операції, які дозволяють виконати кілька змін як
єдине ціле: або commit усіх, або rollback усіх.

Використовуються для multi-document/multi-collection сценаріїв.

**Коротко:**

- Транзакція гарантує атомарність набору операцій.
- Потрібна, коли одна операція охоплює кілька документів.
- Для одиночного документа атомарність є й без транзакції.

</details>

<details>
<summary>62. У яких випадках варто використовувати транзакції?</summary>

#### MongoDB

Транзакції потрібні, коли важлива узгодженість між кількома документами:

- переказ коштів між рахунками;
- резерв товару + створення замовлення;
- синхронні зміни в кількох колекціях.

Якщо задачу можна вирішити атомарним оновленням одного документа, транзакція
зазвичай не потрібна.

**Коротко:**

- Використовуйте транзакції тільки для справді multi-document консистентності.
- Не застосовуйте їх "за замовчуванням".
- Менша кількість транзакцій зазвичай = краща продуктивність.

</details>

<details>
<summary>63. Чим транзакції MongoDB відрізняються від транзакцій у SQL?</summary>

#### MongoDB

Концептуально ACID схожий, але відмінність у моделі даних:

- у MongoDB багато сценаріїв закриваються атомарністю одного документа;
- у SQL частіше потрібні multi-row/табличні транзакції через нормалізацію.

У MongoDB транзакції зазвичай дорожчі за звичайні одно-документні операції.

**Коротко:**

- ACID-механіка схожа, модель використання відрізняється.
- MongoDB частіше проєктують так, щоб мінімізувати транзакції.
- Транзакції застосовують там, де без них не гарантується консистентність.

</details>

<details>
<summary>64. Як транзакції впливають на продуктивність?</summary>

#### MongoDB

Транзакції додають накладні витрати: триваліші блокування ресурсів, більше
пам'яті/журналювання, вищу latency.

Щоб мінімізувати вплив:

- робити транзакції короткими;
- зменшувати кількість документів у транзакції;
- уникати довгих бізнес-операцій усередині транзакції.

**Коротко:**

- Транзакції підвищують вартість операцій.
- Короткі та вузькі транзакції працюють стабільніше.
- Необхідно балансувати консистентність і throughput.

</details>

<details>
<summary>65. Що таке write concern?</summary>

#### MongoDB

`writeConcern` визначає, скільки вузлів повинні підтвердити запис.

Приклади:

- `w: 1` — підтвердження primary;
- `w: "majority"` — підтвердження більшості реплік.

`j: true` додає підтвердження запису в journal.

**Коротко:**

- `writeConcern` керує надійністю запису.
- `majority` підвищує стійкість до збоїв.
- Вища надійність зазвичай підвищує latency запису.

</details>

<details>
<summary>66. Що таке read concern?</summary>

#### MongoDB

`readConcern` визначає рівень узгодженості даних, які повертає читання.

Поширені рівні: `local`, `majority`, `snapshot` (для транзакцій).

Вибір залежить від компромісу між свіжістю, консистентністю і затримкою.

**Коротко:**

- `readConcern` задає гарантії читання.
- `majority` дає більш стійке до rollback читання.
- Вища консистентність може коштувати дорожче по latency.

</details>

<details>
<summary>67. Що таке read preference?</summary>

#### MongoDB

`readPreference` визначає, з яких вузлів replica set читати дані:
`primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`.

Для критично консистентних read-after-write сценаріїв зазвичай використовують
`primary`.

**Коротко:**

- `readPreference` розподіляє навантаження читання.
- `secondary` може зменшити тиск на primary.
- Режим читання впливає на свіжість даних.

</details>

<details>
<summary>68. Що таке replica set?</summary>

#### MongoDB

Replica set — це група MongoDB-вузлів з реплікацією даних для high
availability.

Типово складається з primary, secondary і опційно arbiter.

**Коротко:**

- Replica set забезпечує відмовостійкість і реплікацію.
- Один вузол приймає записи (primary), інші реплікують (secondary).
- Основа production-розгортань MongoDB.

</details>

<details>
<summary>69. Як працює primary і secondary?</summary>

#### MongoDB

`Primary` приймає write-операції та веде oplog. `Secondary` асинхронно
реплікують зміни з oplog primary.

У разі відмови primary один з secondary обирається новим primary.

**Коротко:**

- Записи йдуть на primary.
- Secondary копіюють зміни через oplog.
- Архітектура дозволяє безперервність сервісу при збоях вузла.

</details>

<details>
<summary>70. Що таке автоматичне перемикання (failover)?</summary>

#### MongoDB

Failover — це автоматичне обрання нового primary у replica set, якщо поточний
primary недоступний.

Клієнтський драйвер, за коректного connection string, перепідключається до
нового primary автоматично.

**Коротко:**

- Failover зменшує downtime при відмові primary.
- Новий primary обирається election-механізмом.
- Драйвери повинні бути налаштовані на роботу з replica set.

</details>

<details>
<summary>71. Що таке sharding?</summary>

#### MongoDB

Sharding — це горизонтальне масштабування, коли дані розподіляються між кількома
шардами за shard key.

Це дозволяє масштабувати storage і throughput за межі одного вузла.

**Коротко:**

- Sharding ділить дані між вузлами.
- Дає горизонтальне масштабування читання/запису.
- Критично залежить від правильного shard key.

</details>

<details>
<summary>72. Коли потрібно використовувати sharding?</summary>

#### MongoDB

Sharding потрібен, коли:

- дані не вміщаються на одному сервері;
- write/read throughput перевищує можливості одного replica set;
- потрібне масштабування з передбачуваним ростом.

Перед sharding треба оптимізувати схему, індекси і запити.

**Коротко:**

- Використовуйте sharding при реальному ліміті single-cluster ресурсів.
- Це інструмент масштабування, а не первинної оптимізації.
- Спочатку індекси й модель даних, потім sharding.

</details>

<details>
<summary>73. Що таке shard key?</summary>

#### MongoDB

Shard key — поле або набір полів, за якими MongoDB розподіляє документи по
шардах.

Від shard key залежить рівномірність даних і розподіл навантаження.

**Коротко:**

- Shard key керує маршрутизацією даних між шардами.
- Невдалий ключ створює hot shard і дисбаланс.
- Вибір ключа — ключове архітектурне рішення в sharded-системі.

</details>

<details>
<summary>74. Які критерії вибору shard key?</summary>

#### MongoDB

Критерії:

1. Висока cardinality.
2. Рівномірний розподіл значень.
3. Відповідність частим запитам.
4. Відсутність монотонного росту, що створює гарячі партиції.

Часто використовують compound shard key для балансу між routing і розподілом.

**Коротко:**

- Ключ має рівномірно розподіляти дані і запити.
- Висока cardinality зазвичай обов'язкова.
- Ключ повинен відповідати реальному query pattern.

</details>

<details>
<summary>75. Як працює балансування даних між шардами?</summary>

#### MongoDB

Balancer переміщує chunks між шардами, щоб вирівнювати обсяг даних і
навантаження.

Процес працює фоново і спирається на метадані кластеру.

**Коротко:**

- Балансер перерозподіляє chunks між шардами.
- Мета: уникати перекосу даних і hot shard.
- Якість балансування прямо залежить від shard key.

</details>

<details>
<summary>76. Що таке WiredTiger cache?</summary>

#### MongoDB

WiredTiger cache — це частина RAM, яку storage engine використовує для гарячих
даних, індексів і внутрішніх структур.

Ефективний cache зменшує кількість дискових читань і стабілізує latency.

**Коротко:**

- WiredTiger cache тримає найчастіше використовувані дані в пам'яті.
- Впливає на I/O і загальну швидкодію.
- Нестача cache проявляється ростом дискової активності й latency.

</details>

<details>
<summary>77. Як MongoDB використовує оперативну пам’ять?</summary>

#### MongoDB

RAM використовується для:

- cache даних та індексів (WiredTiger);
- робочих наборів запитів;
- буферів сортування/агрегацій;
- службових процесів реплікації і журналювання.

Головна ціль — щоб "гарячий" working set максимально вміщався в пам'ять.

**Коротко:**

- MongoDB активно покладається на RAM для швидкого доступу.
- Найважливіше — тримати working set у пам'яті.
- Дефіцит RAM різко збільшує disk I/O.

</details>

<details>
<summary>78. Як моніторити продуктивність MongoDB?</summary>

#### MongoDB

Моніторинг включає:

- latency read/write;
- throughput операцій;
- cache hit ratio;
- utilization CPU/RAM/disk;
- replication lag;
- повільні запити.

У self-hosted використовують `mongostat`, `mongotop`, profiler, системні метрики;
в Atlas — вбудований Performance Advisor і dashboards.

**Коротко:**

- Моніторинг має покривати БД і інфраструктуру одночасно.
- Ключові сигнали: latency, lag, cache, slow queries.
- Регулярний моніторинг запобігає деградації продуктивності.

</details>

<details>
<summary>79. Що таке profiler у MongoDB?</summary>

#### MongoDB

Profiler записує інформацію про операції в `system.profile` для аналізу
повільних або всіх запитів (залежно від рівня).

```js
db.setProfilingLevel(1, { slowms: 100 })
```

Рівні: `0` (off), `1` (slow ops), `2` (all ops).

**Коротко:**

- Profiler дає деталі виконання запитів на рівні БД.
- Найчастіше використовують рівень `1` з порогом `slowms`.
- Допомагає точно локалізувати дорогі операції.

</details>

<details>
<summary>80. Які найпоширеніші проблеми продуктивності в MongoDB?</summary>

#### MongoDB

Типові проблеми:

- відсутні або невдалі індекси;
- надлишкові індекси (write overhead);
- великі документи і безмежні масиви;
- неефективні `$lookup`/`$group`;
- deep pagination через великий `skip`;
- нерівномірний shard key у sharded-кластері.

**Коротко:**

- Найчастіша причина повільної роботи — індекси і модель даних.
- Проблеми з schema design швидко масштабуються разом з трафіком.
- Регулярний аудит запитів і індексів обов'язковий.

</details>

<details>
<summary>81. Що таке MongoDB Atlas?</summary>

#### MongoDB

MongoDB Atlas — керований хмарний сервіс MongoDB з автоматизацією розгортання,
оновлень, backup, моніторингу та безпеки.

Підтримує replica set, sharding, Atlas Search і Vector Search.

**Коротко:**

- Atlas = managed MongoDB у хмарі.
- Знімає операційне навантаження з команди.
- Дає готові production-інструменти з коробки.

</details>

<details>
<summary>82. У чому різниця між self-hosted MongoDB і MongoDB Atlas?</summary>

#### MongoDB

Self-hosted:

- повний контроль над інфраструктурою;
- команда сама керує backup, upgrades, HA, security.

Atlas:

- більшість операцій автоматизована;
- швидший запуск і масштабування;
- інтегровані monitoring, alerting, advisor-інструменти.

**Коротко:**

- Self-hosted дає максимальний контроль, але більший операційний тягар.
- Atlas спрощує експлуатацію і прискорює delivery.
- Вибір залежить від вимог комплаєнсу, бюджету і ресурсів команди.

</details>

<details>
<summary>83. Що таке Atlas Serverless?</summary>

#### MongoDB

Atlas Serverless — модель, де обчислювальні ресурси автоматично підлаштовуються
під навантаження без ручного керування кластерами.

Підходить для нерівномірного трафіку і швидкого старту.

**Коротко:**

- Serverless прибирає керування інстансами вручну.
- Ресурси масштабуються за фактичним навантаженням.
- Зручно для bursty workload і MVP/продуктів із змінним трафіком.

</details>

<details>
<summary>84. Як працює autoscaling у MongoDB Atlas?</summary>

#### MongoDB

Autoscaling автоматично змінює ресурси кластера (compute/storage) за порогами
навантаження, заданими конфігурацією Atlas.

Це допомагає уникати ручного масштабування під піковий трафік.

**Коротко:**

- Autoscaling реагує на ріст навантаження і даних.
- Знижує ризик деградації при піках.
- Потрібно контролювати ліміти і вартість.

</details>

<details>
<summary>85. Які можливості моніторингу та алертів доступні в Atlas?</summary>

#### MongoDB

Atlas надає:

- dashboards по latency/ops/resources;
- Performance Advisor;
- Database Profiler integration;
- алерти по CPU, RAM, disk, replication lag, connections, query latency;
- інтеграції з зовнішніми каналами нотифікацій.

**Коротко:**

- Atlas має вбудований production-моніторинг.
- Алерти можна налаштувати на ключові SLO-метрики.
- Performance Advisor допомагає з індексацією запитів.

</details>

<details>
<summary>86. Що таке Atlas Search?</summary>

#### MongoDB

Atlas Search — це керований пошуковий рушій у MongoDB Atlas на базі Lucene для
повнотекстового, fuzzy, autocomplete і гібридного пошуку.

Використовується через стадію `$search` в aggregation.

**Коротко:**

- Atlas Search дає розширений пошук понад базовий `text index`.
- Підтримує relevance, autocomplete, fuzzy та аналітику пошуку.
- Інтегрується нативно в MongoDB pipeline.

</details>

<details>
<summary>87. Чим Atlas Search відрізняється від text index?</summary>

#### MongoDB

`text index`:

- базовий full-text через `$text`;
- обмежені можливості ранжування й аналізаторів.

Atlas Search:

- гнучкі analyzers, scoring, fuzzy, synonyms, autocomplete;
- кращий контроль relevance і пошукової логіки.

**Коротко:**

- `text index` простіший і базовий.
- Atlas Search значно потужніший для production-пошуку.
- Для складного search UX зазвичай обирають Atlas Search.

</details>

<details>
<summary>88. Як реалізувати повнотекстовий пошук у MongoDB Atlas?</summary>

#### MongoDB

Кроки:

1. Створити Search Index в Atlas.
2. Використати `$search` у pipeline.
3. Додати фільтри, сортування і ліміти.

```js
db.articles.aggregate([
  {
    $search: {
      index: "default",
      text: { query: "mongodb sharding", path: ["title", "content"] }
    }
  },
  { $limit: 20 }
])
```

**Коротко:**

- Потрібен окремий Search Index у Atlas.
- Запит виконується через `$search`.
- Далі застосовуються звичайні стадії aggregation.

</details>

<details>
<summary>89. Що таке autocomplete index в Atlas Search?</summary>

#### MongoDB

Autocomplete index оптимізований для пошуку підрядків/префіксів у live search
(підказки під час введення).

Використовується з оператором `autocomplete` у `$search`.

**Коротко:**

- Дає швидкі підказки "на льоту".
- Працює краще за regex для пошукового UX.
- Налаштовується окремим типом поля в Search Index.

</details>

<details>
<summary>90. У яких випадках варто використовувати Atlas Search?</summary>

#### MongoDB

Atlas Search доцільний, коли потрібні:

- релевантний повнотекстовий пошук;
- fuzzy/synonym/autocomplete;
- складний search UX з ранжуванням.

Для простих сценаріїв "знайти слово" може вистачати `text index`.

**Коротко:**

- Atlas Search потрібен для складного пошуку й релевантності.
- Підходить для каталогів, контенту, knowledge base, e-commerce.
- Для базових задач можливий lighter варіант через `text index`.

</details>

<details>
<summary>91. Що таке Vector Search у MongoDB?</summary>

#### MongoDB

Vector Search — це пошук за близькістю embedding-векторів для семантичного
порівняння контенту.

Замість точного збігу слів система шукає "схожий за змістом" текст.

**Коротко:**

- Vector Search працює по embedding-представленнях.
- Дозволяє semantic similarity пошук.
- Базовий компонент AI/RAG-сценаріїв.

</details>

<details>
<summary>92. Як зберігати embeddings у MongoDB?</summary>

#### MongoDB

Embedding зазвичай зберігають як масив чисел у полі документа разом з
метаданими джерела.

```js
db.docs.insertOne({
  title: "MongoDB sharding guide",
  content: "...",
  embedding: [0.013, -0.224, 0.991],
  source: "kb",
  createdAt: new Date()
})
```

Далі налаштовується vector index для similarity search.

**Коротко:**

- Embedding зберігається в масиві числових значень.
- Поруч тримають metadata для фільтрації.
- Для пошуку потрібен vector index.

</details>

<details>
<summary>93. Як працює semantic search?</summary>

#### MongoDB

Semantic search порівнює вектор запиту з векторами документів і повертає
найближчі за змістом результати.

Потік:

1. Перетворити запит у embedding.
2. Виконати vector similarity пошук.
3. За потреби додати фільтри/гібридний ранкінг.

**Коротко:**

- Пошук ґрунтується на змісті, а не лише на словах.
- Ключовий елемент — якісні embeddings.
- Часто комбінується з класичним keyword search.

</details>

<details>
<summary>94. Як MongoDB використовується в AI або RAG-системах?</summary>

#### MongoDB

MongoDB у RAG використовується як операційне + пошукове сховище:

- зберігання документів і метаданих;
- зберігання embeddings;
- vector/keyword пошук для retrieval;
- журналювання діалогів і контексту.

Типовий flow: ingest -> chunking -> embedding -> index -> retrieval -> generation.

**Коротко:**

- MongoDB закриває зберігання контенту і retrieval-шар.
- Підтримує hybrid search для RAG-пайплайнів.
- Дає єдину платформу для operational + AI-data workload.

</details>

<details>
<summary>95. Що таке connection string і як підключитися до MongoDB?</summary>

#### MongoDB

Connection string — URI з параметрами доступу до MongoDB: хости, БД,
автентифікація, TLS, replica set, read/write policy.

```txt
mongodb+srv://app_user:strongPass@cluster0.example.mongodb.net/appdb?retryWrites=true&w=majority
```

У production credentials зберігають у secret manager або environment variables.

**Коротко:**

- Connection string описує, куди і як підключатися.
- Для Atlas зазвичай використовують `mongodb+srv://`.
- Облікові дані не зберігають у коді.

</details>

<details>
<summary>96. Як працює connection pooling?</summary>

#### MongoDB

Connection pooling — це повторне використання набору відкритих з'єднань замість
створення нового з'єднання на кожен запит.

Практика:

- ініціалізувати один клієнт на процес;
- налаштовувати `maxPoolSize`, `minPoolSize`, `maxIdleTimeMS` під workload;
- уникати частого `connect/disconnect`.

**Коротко:**

- Пул з'єднань знижує latency і навантаження на БД.
- Клієнт зазвичай має бути singleton у сервісі.
- Розмір пулу налаштовують під реальний concurrency.

</details>

<details>
<summary>97. Які best practices безпеки в MongoDB?</summary>

#### MongoDB

Ключові практики:

1. Увімкнути authentication і TLS.
2. Використовувати RBAC з least privilege.
3. Ізолювати мережевий доступ (allowlist/private networking).
4. Регулярно ротуати секрети.
5. Увімкнути audit/logging для критичних середовищ.
6. Своєчасно оновлювати версії MongoDB/драйверів.

**Коротко:**

- Безпека = auth + шифрування + мінімальні права.
- Мережеве обмеження доступу критичне для production.
- Оновлення і аудит знижують ризик компрометації.

</details>

<details>
<summary>98. Як працює role-based access control (RBAC)?</summary>

#### MongoDB

RBAC надає права через ролі, прив'язані до користувачів.

Роль містить дозволи на дії (`find`, `insert`, `update`, `remove`, admin-операції)
для конкретних БД/колекцій.

```js
db.grantRolesToUser("app_user", [{ role: "readWrite", db: "appdb" }])
```

**Коротко:**

- RBAC керує доступом через ролі, а не через точкові винятки.
- Права видають за принципом least privilege.
- Ролі мають бути розділені за функціями сервісів.

</details>

<details>
<summary>99. Як виконувати резервне копіювання та відновлення даних?</summary>

#### MongoDB

Варіанти backup:

- логічні дампи (`mongodump`/`mongorestore`);
- snapshot backup (Atlas/self-hosted storage snapshots);
- point-in-time recovery (де доступно).

Практика:

- автоматизувати backup schedule;
- тестувати restore регулярно;
- контролювати RPO/RTO вимоги.

**Коротко:**

- Backup без регулярного тесту restore не вважається надійним.
- Стратегія визначається RPO/RTO та обсягом даних.
- Для production потрібна автоматизація і перевірка відновлення.

</details>

<details>
<summary>100. Які архітектурні best practices для масштабування MongoDB у production?</summary>

#### MongoDB

Практичний набір:

1. Проєктувати схему і індекси під реальні запити.
2. Впроваджувати replica set як базовий стандарт HA.
3. Додавати sharding лише при досягненні ресурсних меж.
4. Використовувати observability: метрики, профайлер, алерти.
5. Контролювати growth даних: TTL, архівація, lifecycle policy.
6. Регулярно переглядати query plans і індекси.

**Коротко:**

- Масштабування починається з моделі даних і індексів.
- Відмовостійкість, моніторинг і backup мають бути вбудовані з першого дня.
- Шардінг застосовують як керований етап еволюції системи.

</details>
